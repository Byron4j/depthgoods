# 1.有看过HashMap源码吗？

1. JDK1.7中HashMap的put()方法全过程。
2. JDK1.8有那些变化。
3. JDK1.7当中HashMap中线程不安全问题有那些？原因分别是什么？
4. JDK1.8之后如何链地址法，链表长度是多少的时候会转换成红黑树。
5. 节点个数是多少的时候，红黑树会退回链表。
6. 为什么会选择8作为链表转红黑树的阈值。

>泊松分布，在负载因子默认为0.75的时候，单个hash槽内元素个数为8的概率小于百万分之一，所以将7作为一个分水岭，等于7的时候不转换，大于等于8的时候才进行转换，小于等于6的时候就化为链表。

# 2.HashMap与HashTable有什么区别？

- 有没有了解过ConcurrentHashMap?
- JDK1.8之后ConcurrentHashMap如何保证线程安全性?(CAS+synchronized)，这里还顺便问了synchronized和可重入锁的区别。
- 与JDK1.7相比有那些优化？

# 3.说到synchronized

说到synchronized，说些synchronized加载static关键字前和普通方法前的区别？

1. >Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”
   >
   >Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。
   >
   >对象锁钥匙只能有一把才能互斥，才能保证共享变量的唯一性
   >在静态方法上的锁，和 实例方法上的锁，默认不是同样的，如果同步需要制定两把锁一样。
   >关于同一个类的方法上的锁，来自于调用该方法的对象，如果调用该方法的对象是相同的，那么锁必然相同，否则就不相同。比如 new A().x() 和 new A().x(),对象不同，锁不同，如果A的单利的，就能互斥。
   >静态方法加锁，能和所有其他静态方法加锁的 进行互斥
   >静态方法加锁，和xx.class 锁效果一样，直接属于类的

# 4.单例模式、单例模式的优缺点

1. >优点：
   >
   >在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
   >避免对资源的多重占用（比如写文件操作）。
   >缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。
   >
   >使用场景：
   >
   >要求生产唯一序列号。
   >WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
   >创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。

# 5.JVM的内存模型

## 5.1 方法区

## 5.2 堆区

## 5.3 java线程栈

## 5.4 本地方法栈

## 5.5 PC程序计数器



# 6.垃圾回收算法

## 6.1 标记清除

## 6.2 复制算法

## 6.3 标记整理

## 6.4 分代收集

# 7. 垃圾收集器

## CMS收集器

### 特点

### 过程

## G1收集器

### 特点

### 过程



# 8. JVM创建对象的过程

常量池中定位类的符号引用

 ↓

检查符号引用所代表的类是否已被加载，解析和初始化过 →

 ↓ ↓

分配内存（类加载完成后，内存需求确定） ← 加载

 ↓

根据java堆是否规整（GC方法）选择分配方法

 ↙ ↘

指针碰撞 空闲列表

 ↓

分配内存的并发保证（指针更新的原子性）

 ↙ ↘

CAS+失败重试 按照线程划分在不同的空间中进行TLAB -XX:+UseTLAB -XX:-UseTLAB

 ↓

内存空间初始化为0值，保证对象的实例字段可以不赋初值就可以使用。

 ↓

设置对象头信息（Object Header）：引用指针，元数据，hash值，GC分代年龄，锁相关

 ↓

执行对象方法

说一下byte a = 127， byte b = 127; a+=b 和a = a+b的区别分别会出现什么问题。

a+=b 会出现负数。

a=a+b 会直接报错。

强制类型提升造成的



# 9. MVCC

MVCC(Mutil-Version Concurrency Control)，就是多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。

在Mysql的InnoDB引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于SELECT操作会访问版本链中的记录的过程。

这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。



操作的是快照版本的数据。



# 10. MySQL索引

# 11. MySQL优化

# 12. 动态代理2种方式

一种是JDK动态代理，另一种是CGLib的方式。

## JDK动态代理具体实现原理

通过实现InvocationHandlet接口创建自己的调用处理器；

通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理；

通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型；

通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入；

JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力，Spring通过Java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。

## CGLib动态代理

CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过 CGlib继承要被动态代理的类，重写父类的方法，实现AOP面向切面编程呢。

## 两者对比

### 特征

JDK动态代理是面向接口的。

CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么抱歉会失败）。

### 性能

关于两者之间的性能的话，JDK动态代理所创建的代理对象，在以前的JDK版本中，性能并不是很高，虽然在高版本中JDK动态代理对象的性能得到了很大的提升，但是他也并不是适用于所有的场景。

主要体现在如下的两个指标中

CGLib所创建的动态代理对象在实际运行时候的性能要比JDK动态代理高不少，有研究表明，大概要高10倍；

但是CGLib在创建对象的时候所花费的时间却比JDK动态代理要多很多，有研究表明，大概有8倍的差距；

### 选择

因此，对于singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用CGLib动态代理，反正，则比较适用JDK动态代理。



# 13. Spring的事务传播行为

```java
public interface TransactionDefinition {
    int PROPAGATION_REQUIRED = 0;
    int PROPAGATION_SUPPORTS = 1;
    int PROPAGATION_MANDATORY = 2;
    int PROPAGATION_REQUIRES_NEW = 3;
    int PROPAGATION_NOT_SUPPORTED = 4;
    int PROPAGATION_NEVER = 5;
    int PROPAGATION_NESTED = 6;
}
```

- PROPAGATION_REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。
- PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。
- PROPAGATION_MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常。
- PROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。
- PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
- PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。
- PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。



常用的主要有Required，RequiresNew，Nested三种。



**Required**：有事务就用已有的，没有就重新开启一个。
**RequiresNew**：开启新事务，若当前已有事务，挂起当前事务。新开启的事务和之前的事务无关，拥有自己的锁和隔离级别，可以独立提交和回滚，内层事务执行期间，外层事务挂起，内层事务执行完成后，外层事务恢复执行。
**Nested**：简单理解就是嵌套事务，如果外部事务回滚，则嵌套事务也会回滚！！！外部事务提交的时候，嵌套它才会被提交。嵌套事务回滚不会影响外部事务。子事务是上层事务的嵌套事务，在子事务执行之前会建立savepoint，嵌套事务的回滚会回到这个savepoint，不会造成父事务的回滚。

如果想事务一起执行可以用Required满足大部分场景，如果不想让执行的子事务的结果影响到父事务的提交可以将子事务设置为RequiresNew。



- [参考一](https://blog.csdn.net/qq_35190492/article/details/103795708?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)